# Merchant's Guide to the Galaxy

The Merchant's Guide to the Galaxy is a simple programming exercise that's often used to screen candidates for software developer positions. Here's the [Problem Description](ProblemDescription.md).  

## Approach

I decided to work the exercise as if I were on a team developing microservices. Our team follows generally-accepted contemporary development practices. 

What does that mean to me? 

It means:

- The solution architecture is "given" - it will be a conventional cloud-based microservice.
- A proper development environment includes, as a baseline, a version control system, development tools such as an IDE or editor; compilers, linkers, packaging tools, etc.; continuous integration support; unit testing support; static code analysis support; and automated deployment. Setting up this environment is the first step for a greenfield project like this. Circa 2020, just typing code into an editor without having a proper deployment pipeline is not a professional approach. 
- Collaborative work generally yields the best results. [Mob Programming](https://mobprogramming.org/) is the most highly collaborative working style for software development that has been defined as of this writing. My team comprises one person, so it will be a mob of one; but if it were four or six or 12 people, we would still carry out just one task at a time, working collaboratively. In other words, we set a [work-in-process (WIP) limit](https://kanbanize.com/kanban-resources/getting-started/what-is-wip/) of one. 
- With a WIP limit of one and no cross-team dependencies, it's easy to use a simple branching strategy known as [trunk-based development](https://trunkbaseddevelopment.com/). When teams struggle with this strategy, it usually means they are doing certain other things in ways that create challenges for them, such as having too much work in process (WIP) and separating each piece of work into a separate branch (such as a [feature branch](https://www.atlassian.com/git/tutorials/comparing-workflows/feature-branch-workflow) or [task branch](https://stackoverflow.com/questions/22098634/how-to-do-a-branch-per-task-strategy-with-git) or similar, especially combined with non-collaborative, individual work), defining their individual work items to be complicated or large, or keeping unfinished changes in various long-lived branches. The reason is _never_ that trunk-based development "doesn't work." 
- Development work follows the _test-first_ approach to [test-driven development](https://en.wikipedia.org/wiki/Test-driven_development) (TDD). We'll use a mixture of [classic and mockist](https://paulbellamy.com/2018/12/testing-with-intent-5-two-schools-of-tdd) TDD, as many experienced practitioners do. We'll start with an _outside-in_ approach using the mockist style (or London School) of TDD, beginning at the acceptance test level. That will give us an end-to-end picture of the solution, and a set of test cases we can think of as a target to aim for. Then we'll flesh out the solution following an _inside_out_ approach, using classic style (or Detroit School) of TDD to support [emergent design](https://en.wikipedia.org/wiki/Emergent_Design) and [iterative development with incremental delivery](https://en.wikipedia.org/wiki/Iterative_and_incremental_development). These techniques are so poorly understood across the industry that nearly any information you might find in an Internet search will be at least slightly off-target; but don't worry: They remain practical and useful, even when our understanding diverges from that of a technique's inventors. 
- We'll decompose our work into [vertical slices](https://en.wikipedia.org/wiki/Vertical_slice) of functionality. That helps us be sure whatever we release will be of at least _some_ use to our customers. It also helps us deliver _something_ rather than the usual nothing early in the project. Given the choice, many customers prefer something over nothing.
- We'll define our work in terms of _stories_, derived from the idea of [User Stories](https://en.wikipedia.org/wiki/User_story). A _story_ is a lightweight description of a piece of software functionality as it is experienced by its _user_ (human or machine). It includes (a) who needs the functionality, (b) what value the functionality provides to the "who," (c) a brief description of the functionality, and (d) the "acceptance criteria," which tell us when we're finished with the story. Formats vary widely. 
- Notwithstanding the fact we're working in _stories_, the first thing we do won't be one. Instead, we will verify that we have set up the development and deployment tooling correctly. Often, when setting things up for the first time for a greenfield development project, the first "story" isn't a _story_ at all, but a demonstration that a message can flow from the UI or API all the way through the solution architecture and back again. 

